![](https://upic-1257948216.cos.ap-chengdu.myqcloud.com/uPic/n-tho-duc-e4VMuIINdPs-unsplash.jpeg)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]


提示：

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

### 解法一：暴力循环法

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length-1; i++ ) {
            for (int j = i+1; j< nums.length; j++ ) {
                if ( nums[i]+nums[j] == target ){
                    return new int[]{i,j};
                }
            }
        }
        return new int[]{0};
    }
}
```

```go
func twoSum(nums []int, target int) []int {
  for i := 0; i < len(nums) - 1; i++ {
    for j := i + 1; j < len(nums); j++ {
      if nums[i]+nums[j] == target {
        return []int{i,j}
      }
    }
  }
  return []int{}
}
```

暴力破解虽可以得出结果，但是，时间复杂度是O(n2)的，如果说必须要求时间复杂度要小于O(n2)，那么：

### 解法二：哈希映射

**思路**
1、由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度
2、遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值
3、如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止

**复杂度分析**

时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。

空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。

![img](https://pic.leetcode-cn.com/146e209493728cd7b9fd6095c5947300732799db9b28b2f8e497525ea7b31d58-Messages%20Image(1369442164).png)

![img](https://pic.leetcode-cn.com/d54dcd98bf9b8f5f5575893a9c253dda04cb177436322a9b41ce89290deb651d-Messages%20Image(3072076888).png)

![img](https://pic.leetcode-cn.com/c486f3ff7e4b810dd228acad621aa76899eb39b053723d663fc0359dc1d85fac-Messages%20Image(645062534).png)

![img](https://pic.leetcode-cn.com/89121495efbd8b51444cf5a4a1326073e1bd801cd7070a4d82a6897d3c86ba9f-Messages%20Image(2668429756).png)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (map.containsKey(target - nums[i])) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
```

```go
func twoSumWithMap(nums []int, target int) []int {
	m := make(map[int]int, 0)
	for i, v := range nums {
		if k, e := m[target-v]; e {
			return []int{k, i}
		}
		m[v] = i
	}
	return []int{}
}
```

### 解法三：哈希映射+双向指针

上面的解法还有优化的余地，因为是从一头开始匹配的，如果从前后同时匹配是不是会更快吃到热豆腐，改良一下：

```java
class Solution {
  public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    int left = 0,right = nums.length - 1;
    while (left<= right){
      if (map.containsKey(target - nums[left])) {
        return new int[]{map.get(target - nums[left]), left};
      }
      map.put(nums[left],left);
      if (map.containsKey(target - nums[right])) {
        return new int[]{right, map.get(target - nums[right])};
      }
      map.put(nums[right],right);
    }
    return new int[]{};
  }
}
```



```go
func TwoSumWithDoublePoint(nums []int, target int) []int {
	left, right := 0, len(nums)-1
	m := make(map[int]int, 0)
	for left <= right {
		if l, ok := m[target-nums[left]]; ok {
			return []int{l, left}
		}
		m[nums[left]] = left
		if r, ok := m[target-nums[right]]; ok {
			return []int{right, r}
		}
		m[nums[right]] = right
		left++
		right--
	}
	return []int{}
}
```

