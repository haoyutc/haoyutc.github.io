## 题目

> 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
>
> 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
>
> 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,3,2,2,5,2,3,7]
> 输出：5
> 解释：最长的和谐子序列是 [3,2,2,2,3]
> 示例 2：
>
> 输入：nums = [1,2,3,4]
> 输出：2
> 示例 3：
>
> 输入：nums = [1,1,1,1]
> 输出：0
>
>
> 提示：
>
> 1 <= nums.length <= 2 * 104
> -109 <= nums[i] <= 109
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/longest-harmonious-subsequence

## 题解

### 方法一(排序+滑动窗口)：

#### 思路与算法

> 最先想到的就是，先对数组进行排序，然后使用双指针，按照滑动窗口进行扫描，统计出所有符合条件的窗口长度，并取所有窗口长度中的最大值。

#### Talk is cheap, Show me the code.

**Java**

```java
    // 排序+滑动窗口
    public int findLHS(int[] nums) {
        Arrays.sort(nums);
        int res = 0;
        for (int begin = 0, end = 1; end < nums.length; end++) {
            while (nums[end] - nums[begin] > 1) {
                begin++;
            }
            if (nums[end] - nums[begin] == 1) {
                res = Math.max(res, end - begin + 1);
            }
        }
        return res;
    }

    @Test
    public void testFindLHS() {
        int[] nums1 = {1, 3, 2, 2, 5, 2, 3, 7};
        int[] nums2 = {1, 2, 3, 4};
        int[] nums3 = {1, 1, 1, 1};
        int[] nums4 = {1,3,5,7,9,11,13,15,17};
        Assert.assertEquals(5, findLHS(nums1));
        Assert.assertEquals(2, findLHS(nums2));
        Assert.assertEquals(0, findLHS(nums3));
        Assert.assertEquals(0, findLHS(nums4));
    }
```



**Golang**

```go
func findLHS(nums []int) int {
	sort.Ints(nums)
	begin := 0
	res := 0
	for end, num := range nums {
		for num-nums[begin] > 1 {
			begin++
		}
		if num-nums[begin] == 1 {
			res = int(math.Max(float64(ans), float64(end-begin+1)))
		}
	}
	return res
}

func Test_findLHS(t *testing.T) {
	type args struct {
		nums []int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		// TODO: Add test cases.
		{"nums1",args{[]int{1,1,1,1}},0},
		{"nums1",args{[]int{1,3,2,2,5,2,3,7}},5},
		{"nums1",args{[]int{1,2,3,4}},2},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := findLHS(tt.args.nums); got != tt.want {
				t.Errorf("findLHS() = %v, want %v", got, tt.want)
			}
		})
	}
}
```



### 复杂度分析

>- 时间复杂度：*O(N log N)*，N为数组长度，排序所用时间复杂度：*O(N log N)*，滑动窗口遍历：*O(2N)*，T(N)=O(N log N)+O(2N)
>- 空间复杂度：O(1)，需要常数个空间保存中间变量



### 方法二(哈希计数)：

#### 思路与算法

> 审题所知「和谐子序列」中的最值差值正好为 1，因而子序列排序后必然符合 [a,a,..,a+1,a+1][a,a,..,a+1,a+1] 形式，即符合条件的和谐子序列长度为相邻两数（差值为 1) 的出现次数之和。
>
> 故可以使用「哈希表」记录所有 nums[i] 的出现次数，然后通过 O(n) 的复杂度找出所有可能的数对（两数差值为 1)，并在所有符合条件的数对所能构成的「和谐子序列」长度中取最大值。
>

#### Talk is cheap, Show me the code.

**Java**

```java
    public int findLHS2(int[] nums) {
        Map<Integer, Integer> iMap = new HashMap<>();
        int res = 0;
        for (int num : nums) {
            iMap.put(num, iMap.getOrDefault(num, 0) + 1);
        }
        for (int key : iMap.keySet()) {
            if (iMap.containsKey(key+1)) {
                res = Math.max(res, iMap.get(key) + iMap.get(key + 1));
            }
        }
        return res;
    }

    @Test
    public void testFindLHS2() {
        int[] nums1 = {1, 3, 2, 2, 5, 2, 3, 7};
        int[] nums2 = {1, 2, 3, 4};
        int[] nums3 = {1, 1, 1, 1};
        int[] nums4 = {1,3,5,7,9,11,13,15,17};
        Assert.assertEquals(5, findLHS2(nums1));
        Assert.assertEquals(2, findLHS2(nums2));
        Assert.assertEquals(0, findLHS2(nums3));
        Assert.assertEquals(0, findLHS2(nums4));
    }
```



**Golang**

```go
func findLHS2(nums []int) int {
	nMap := make(map[int]int)
	for _, num := range nums {
		nMap[num]++
	}
	res := 0
	if len(nMap) > 1 {
		for num, cnt := range nMap {
			if nMap[num+1] != 0 {
				res = int(math.Max(float64(res), float64(cnt+nMap[num+1])))
			}
		}
	}
	return res
}

func Test_findLHS2(t *testing.T) {
	type args struct {
		nums []int
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		// TODO: Add test cases.
		{"nums1",args{[]int{1,1,1,1}},0},
		{"nums1",args{[]int{1,3,2,2,5,2,3,7}},5},
		{"nums1",args{[]int{1,2,3,4}},2},
		{"nums1",args{[]int{1,3,5,7,9,11,13,15,17}},0},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := findLHS2(tt.args.nums); got != tt.want {
				t.Errorf("findLHS2() = %v, want %v", got, tt.want)
			}
		})
	}
}
```



### 复杂度分析

>时间复杂度：O(N)，其中 N 为数组的长度。
>
>空间复杂度：O(N)，其中 N 为数组的长度。数组中最多有 N 个不同元素，因此哈希表最多存储 N 个数据。
>



