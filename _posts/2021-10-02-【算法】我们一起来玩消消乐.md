不玩游戏的我突然被面试官邀请来玩一局消消乐游戏，游戏规则是这样的：

> 给出由小写字母组成的字符串 S，连续3个重复项删除操作会选择三个相邻且相同的字母，并删除它们。
>
> 在 S 上反复执行重复项删除操作，直到无法继续删除。
>
> 在完成所有重复项删除操作后返回最终的字符串。
>
> 如：abbbcddde
>
> 结果：ace

乍一看，感觉就这 as aesy as ABC，等我真正的要实现时候，发现没那么简单，并不是手指划几下就能消除的，于是就等通知了！

不得不上LeetCode取经👇

#### [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

> 示例：
>
> 输入："abbaca"
> 输出："ca"
> 解释：
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
>
>
> 提示：
>
> 1 <= S.length <= 20000
> S 仅由小写英文字母组成。

[**思路**](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/shan-chu-zi-fu-chuan-zhong-de-suo-you-xi-4ohr/)

方法一：栈
充分理解题意后，我们可以发现，当字符串中同时有多组相邻重复项时，我们无论是先删除哪一个，都不会影响最终的结果。因此我们可以从左向右顺次处理该字符串。

而消除一对相邻重复项可能会导致新的相邻重复项出现，如从字符串`abba` 中删除 `bb`  会导致出现新的相邻重复项 `aa`  出现。因此我们需要保存当前还未被删除的字符。一种显而易见的数据结构呼之欲出：栈。我们只需要遍历该字符串，如果当前字符和栈顶字符相同，我们就贪心地将其消去，否则就将其入栈即可。

**代码**

```go
func removeDuplicates(s string) string {
	stack := make([]byte, 0)
	for i := range s {
		if len(stack) > 0 && stack[len(stack)-1] == s[i] {
			stack = stack[:len(stack)-1]
		} else {
			stack = append(stack, s[i])
		}
	}
	return string(stack)
}
```

复杂度分析

时间复杂度：O(n)O(n)，其中 nn 是字符串的长度。我们只需要遍历该字符串一次。

空间复杂度：O(n)O(n) 或 O(1)O(1)，取决于使用的语言提供的字符串类是否提供了类似「入栈」和「出栈」的接口。注意返回值不计入空间复杂度。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/shan-chu-zi-fu-chuan-zhong-de-suo-you-xi-4ohr/

看明白没，有了上面的思路，瞬间脑壳一亮啊，同样的运用栈的特性，搞起：

```go
func removeTriples(s string) string {
	stack := make([]byte, 0)
	flag := false
	for i := range s {
		if flag {
			flag = false
			continue
		}
		if len(stack) > 0 && i < len(s)-1 && stack[len(stack)-1] == s[i] && s[i] == s[i+1] {
			stack = stack[:len(stack)-1]
			flag = true
		} else if len(stack) > 2 && i <= len(s)-1 && stack[len(stack)-2] == s[i] && stack[len(stack)-1] == s[i] {
			stack = stack[:len(stack)-2]
		} else {
			stack = append(stack, s[i])
		}
	}
	return string(stack)
}
```

需要注意的是，与相邻重复的不同，三个的会出现，原字符串不重复，经过一番操作后，栈中出现重复的字符

趁热打铁，继续消消乐，上强度

#### [1209. 删除字符串中的所有相邻重复项 II](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/)

> 给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。
>
> 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。
>
> 在执行完所有删除操作后，返回最终得到的字符串。
>
> 本题答案保证唯一。
>
>  
>
> 示例 1：
>
> 输入：s = "abcd", k = 2
> 输出："abcd"
> 解释：没有要删除的内容。
> 示例 2：
>
> 输入：s = "deeedbbcccbdaa", k = 3
> 输出："aa"
> 解释： 
> 先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"
> 再删除 "bbb"，得到 "dddaa"
> 最后删除 "ddd"，得到 "aa"
> 示例 3：
>
> 输入：s = "pbbcggttciiippooaais", k = 2
> 输出："ps"
>
>
> 提示：
>
> 1 <= s.length <= 10^5
> 2 <= k <= 10^4
> s 中只含有小写英文字母。

当k=2、3时，已经有解，这个难度在于k的不确定性，难搞哦！

思路：

- 计数法，遍历字符串，当前字符串与前一个相同，则计数加一，否则，向计数器栈中压入1

- 如果栈顶元素等于 `k`，则从字符串中删除这 `k` 个字符，并将 `k` 从栈顶移除。

```go

func removeDuplicatesWithK(s string, k int) string {
	bytes := []byte(s)
	counter := make([]int, len(s))
	for i := 0; i < len(bytes); i++ {
		if i == 0 || bytes[i] != bytes[i-1] {
			counter[i] = 1
		} else {
			counter[i] = counter[i-1] + 1
			if counter[i] == k {
				bytes = append(bytes[:i-k+1], bytes[i+1:]...)
				i = i - k
			}
		}
	}
	return string(bytes)
}
```

