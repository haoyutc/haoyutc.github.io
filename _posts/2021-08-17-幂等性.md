# 什么是幂等性

- 幂等性定义:
  - 一次和多次请求某一个资源对于资源本身应该具有同样的结果
  - **任意多次执行对资源本身所产生的影响均与一次执行的影响相同**
- 幂等性定义的几个重点:
  - 幂等不仅仅只是一次或者多次请求对资源没有副作用
    - 比如,查询数据库操作,没有增删改,无论多少次操作对数据库都没有任何影响
  - **幂等还包括第一次请求的时候对资源产生了副作用,但是以后的多次请求都不会再对资源产生副作用**
  - **幂等关注的是以后多次请求是否对资源产生副作用,并不关注结果**
  - 网络超时等问题,不是幂等的讨论范围
- 幂等性是系统服务对外一种承诺,而不是实现
- 承诺只要调用接口成功,外部多次调用对系统的影响是一致的
- 声明为幂等的服务会认为外部调用失败是常态,并且失败后必然会有重试

# 幂等性的使用场景

- 业务开发中,经常遇到重复提交的情况:
  - 由于网络问题无法收到请求结果而重新发起请求
  - 前端的操作抖动而造成的重复提交的情况
- 在交易系统中,支付系统这种重复提交造成的问题尤为明显:
  - 用户在APP上连续点击多次提交订单,后台应该只产生一个订单
  - 向支付系统发起请求,由于网络问题或者系统Bug问题导致重发,支付系统应该只做一次扣除操作
- **声明幂等的服务认为,外部调用者会存在多次调用的情况,为了防止外部多次调用对系统的数据状态发生多次改变,需要将服务设计为幂等**

# 幂等和防重

- 重复提交的情况和服务幂等的初衷是不同的
  - 重复提交是在第一次请求已经成功的情况下 **,人为地进行多次操作,** 导致不满足幂等要求的服务多次改变状态
  - 幂等更多使用的情况是第一次请求因为某些情况,不如超时,而导致不知道结果或者请求失败的**异常情况下,发起多次请求**
- 幂等的目的是请求多次确认第一次请求成功,不会因为多次请求而出现多次的状态变化

# 保证幂等性的情况

- 在SQL中,有以下三种场景,只有第三种场景需要保证幂等性:
  - SELECT col1 FROM tab1 WHERE col2=2 **:** 无论执行多少次都不会改变状态,是天然的幂等
  - UPDATE tab1 SET col1=1 WHERE col2=2 **:** 无论执行成功多少次状态都是一致的,也是幂等操作
  - **UPDATE tab1 SET col1=col1+1 WHERE col2=2: 每次执行的结果都会发生变化,这种不是幂等的,要采取策略保证幂等性**

# 设计幂等性服务

- **幂等使得客户端逻辑处理很简单,但是服务端逻辑会很复杂**
- 满足幂等性服务需要包含两点逻辑:
  - **首先去查询上一次的执行状态,如果没有则认为是第一次请求**
  - **在服务改变状态的业务逻辑前保证防重复提交的逻辑**

### 保证幂等策略

- 幂等需要通过唯一的业务单号来保证:

  - **相同的业务单号,认为是同一业务**
  - **使用唯一的业务单号确保:后面多次相同业务单号的处理逻辑和执行效果是一致的**
  
- 幂等实现示例-支付:

  - 先查询订单是否支付过
  - 如果已经支付过,返回支付成功
  - 如果没有支付,则进行支付流程,修改订单的状态为已支付

### 防重复提交策略

- 在保证幂等的策略中,执行是分两步执行的,后面一步依赖上面一步的查询结果,这样就无法保证原子性
- 无法保证原子性在高并发的情况下会存在问题:
  - 第二次请求在第一次请求的下一步订单状态没有修改为"已支付状态"时进行
  - 为了解决这个问题 **:将查询和变更状态操作加锁,并将并行操作改为串行执行**

##### 数据库唯一主键

**方案描述**

数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案 这篇文章），这样才能能保证在分布式环境下 ID 的全局唯一性。

**适用操作：**

插入操作

删除操作

**使用限制：**

需要生成全局唯一主键 ID；



![img](https:////upload-images.jianshu.io/upload_images/25036710-6df2f8aa145cc785.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)



  主要流程：

① 客户端执行创建请求，调用服务端接口。

② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执行数据插入操作，运行对应的 SQL 语句。

③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。

##### 乐观锁

- 如果只是更新已有的数据,没有必要对业务进行加锁

- 设计表结构时使用乐观锁,一般通过

  version

  来实现乐观锁:

  - 保证执行效率
  - 保证幂等



```sql
  UPDATE tab1
  SET   col1=1,version=version+1
  WHERE version=#version# 
```

由于**ABA**问题会导致乐观锁存在失效的情况,只要保证**version**值自增就不会出现**ABA**的问题

##### 防重表

- 使用

  orderNo

  作为去重表中的唯一索引,每次请求都根据订单号

  orderNo

  向去重表中插入一条数据:

  - 第一次请求查询订单支付状态:
    - 订单没有支付
    - 进行支付操作
    - 无论成功与否,执行完成之后更新订单的状态为成功或失败,删除去重表中的数据
    - 后续订单因为表中的唯一索引插入失败,返回操作失败,直到第一次请求完成(成功或者失败)

- **防重表的作用是实现加锁的功能**

##### 分布式锁

- 可以使用Redis分布式锁代替防重表的功能
- 示例:
  - 订单发起支付请求
  - 支付系统会去**Redis**缓存中查询是否存在该订单**Key**
  - 如果不存在,向**Redis**中增加**Key**为订单号
  - 查询订单支付是否已经支付
  - 如果没有则进行支付,支付完成后删除该订单的**Key**
- 通过Redis实现分布式锁,只有这次订单请求完成,下次请求才会进来
- 对比去重表,Redis分布式锁将放并发做在缓存中,效率更高
- **同一时间只能完成一次支付请求**

##### token令牌

- token令牌分为两个阶段:

  - 申请token阶段:

    - 在进入到提交订单页面之前,需要订单系统根据用户信息向支付系统发起一次申请**token**的请求
    - 支付系统将**token**保存到**Redis**缓存中,给支付阶段使用

  - 支付阶段:

    - 订单系统获取到申请的**token,** 发起支付请求

    - 支付系统检查Redis是否存在该token

      如果存在,表示第一次发起支付请求,删除缓存中的**token**开始支付逻辑处理
  
- 如果缓存中不存在,表示非法请求

##### 支付缓冲区

- 支付缓冲区:
  - 将订单的支付请求都快速地接收下来,是一个快速接收请求的缓冲管道
  - 使用**异步**任务处理管道中的数据,过滤调掉重复的待支付的数据
- **优点:** 同步转异步,高吞吐
- **缺点:** 无法及时返回支付结果,需要后续监听支付结果的异步返回



```undefined
幂等的不足:
- 幂等是为了简化客户端逻辑,但是增加了服务提供者的逻辑和成本
- 幂等的使用需要根据具体场景具体分析
- 增加了额外控制幂等的业务逻辑,复杂了业务功能
- 将并行的功能转化为串行,降低了执行效率
```



# 幂等REST API



在REST API的上下文中，当生成多个相同的请求与生成单个请求具有相同的效果时 - 然后该REST API称为**幂等**。

设计REST API时，必须意识到API使用者可能会犯错误。他们可以编写客户端代码，以便可以存在重复请求。这些重复请求可能是无意的以及有意的一些时间（例如由于超时或网络问题）。您必须以这样的方式设计*容错API*，使重复请求不会使系统不稳定。

> 幂等HTTP方法是一种HTTP方法，可以多次调用而不会产生不同的结果。如果只调用一次或十次调用该方法，则无关紧要。结果应该是一样的。它本质上意味着成功执行请求的结果与其执行次数无关。例如，在算术中，向数字加零是幂等操作。

如果您在设计API时遵循REST原则，那么您将拥有用于GET，PUT，DELETE，HEAD，OPTIONS和TRACE HTTP方法的自动**幂等REST API**。只有`POST`API不是幂等的。

1. `POST` 不是幂等的。
2. `GET`，`PUT`，`DELETE`，`HEAD`，`OPTIONS`和`TRACE`是幂等。

让我们分析一下HTTP方法如何最终成为幂等 - 任何POST不是为什么。

## HTTP POST

通常 - 不一定 - 使用`POST`API在服务器上创建新资源。因此，当您调用相同的POST请求N次时，您将在服务器上拥有N个新资源。因此，**POST不是幂等的**。

## HTTP GET，HEAD，OPTIONS和TRACE

`GET`，`HEAD`，`OPTIONS`和`TRACE`方法永远不会改变服务器上的资源状态。它们纯粹用于在那个时间点检索资源表示或元数据。因此，调用多个请求将不会在服务器上进行任何写操作，因此**GET，HEAD，OPTIONS和TRACE是幂等的**。

## HTTP PUT

通常 - 不一定 - 使用`PUT`API来更新资源状态。如果您调用`PUT`API N次，则第一个请求将更新资源; 休息N-1请求将一次又一次地覆盖相同的资源状态 - 实际上不会改变任何东西。因此，**PUT是幂等的**。

## HTTP DELETE

当您调用N个类似的`DELETE`请求时，第一个请求将删除资源，响应将是`200 (OK)`或`204 (No Content)`。其他N-1请求将返回`404 (Not Found)`。显然，响应与第一个请求不同，但服务器端的任何资源都没有状态更改，因为原始资源已被删除。因此，**DELETE是幂等的**。

请记住，如果某些系统可能有这样的DELETE API：

```
DELETE /item/last
```

在上述情况下，调用N次操作将删除N个资源 - 因此`DELETE`在这种情况下不是幂等的。在这种情况下，一个好的建议可能是将上面的API更改为POST - 因为POST不是幂等的。

```
POST /item/last
```

现在，这更接近HTTP规范 - 因此更符合REST。

参考文献：

[Rfc 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)
[SO Thread](https://stackoverflow.com/questions/7016785/is-put-delete-idempotent-with-rest-automatic)

[接口服务设计中幂等性设计的理解，详细分析幂等性设计的几种实现方法](https://www.jianshu.com/p/86bd3648cd05)

[Restful API](http://restful.p2hp.com/)

