1、go语言slice和map底层实现原理？

2、map底层实现原理？

> Golang 中 map 的底层实现是一个散列表，因此实现 map 的过程实际上就是实现散表的过程。
> 在这个散列表中，主要出现的结构体有两个，一个叫hmap(a header for a go map)，一个叫bmap(a bucket for a Go map，通常叫其bucket)。
>
> hmap如下所示：
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bb1faac1ea3.png)



> 图中有很多字段，但是便于理解 map 的架构，你只需要关心的只有一个，就是标红的字段：buckets 数组。Golang 的 map 中用于存储的结构是 bucket数组。而 bucket(即bmap)的结构是怎样的呢？
> bucket：
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bb53eb6d643.png)

> 相比于 hmap，bucket 的结构显得简单一些，标橙的字段依然是“核心”，我们使用的 map 中的 key 和 value 就存储在这里。
>
> “高位哈希值”数组记录的是当前 bucket 中 key 相关的”索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的 bucket 的指针，使得 bucket 会形成一个链表结构。
> 整体的结构应该是这样的：
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bbcf3d8904e.png)
>
> Golang 把求得的哈希值按照用途一分为二：高位和低位。低位用于寻找当前 key属于 hmap 中的哪个 bucket，而高位用于寻找 bucket 中的哪个 key。
> 需要特别指出的一点是：map中的key/value值都是存到同一个数组中的。这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bc2077dd9d7.png)
>
> Map 的扩容：当 Go 的 map 长度增长到大于加载因子所需的 map 长度时，Go 语言就会将产生一个新的 bucket 数组，然后把旧的 bucket 数组移到一个属性字段 oldbucket中。
>
> 注意：并不是立刻把旧的数组中的元素转移到新的 bucket 当中，而是，只有当访问到具体的某个 bucket 的时候，会把 bucket 中的数据转移到新的 bucket 中。

3、slice底层实现原理？

> 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化。
> 切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。
> 切片对象非常小，是因为它是只有3个字段的数据结构：

- 指向底层数组的指针
- 切片的长度
- 切片的容量

这3个字段，就是Go语言操作底层数组的元数据。

![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778ba69a10ebd8.png)

4、map进行有序的排序？

```text
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。
```

5、结构体不加tag可以转json字符串吗？

> - 如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。
> - 如果变量`首字母大写`，则为`public`。
>   - `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
>   - `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用。
>
> ```go
> type Person struct {
> 	id    int    // 小写不加Tag
> 	Name  string `json:"Space"` // 大写加Tag
> 	age   int    `json:"Age"`   // 小写加Tag
> 	Email string // 不加Tag
> }
> 
> func TestJsonConv(t *testing.T) {
> 	p := Person{
> 		id:    111,
> 		Name:  "zhans",
> 		age:   23,
> 		Email: "123@qq.com",
> 	}
> 	fmt.Printf("转换json前结构体内容：%+v\n", p)
> 
> 	pJson, _ := json.MarshalIndent(p, "", "")
> 	//pJson, _ := json.Marshal(p)
> 	fmt.Printf("转换json后结构体内容：%+v\n", string(pJson))
> }
> ```
>
> 结果：
>
> ```go
> 转换json前结构体内容：{id:111 Name:zhans age:23 Email:123@qq.com}
> 转换json后结构体内容：{
> "Space": "zhans",
> "Email": "123@qq.com"
> }
> ```
>
> ## 解释
>
> - 结构体里定义了四个字段，分别对应 `小写无tag`，`小写+tag`，`大写无tag`，`大写+tag`。
> - 转为`json`后首字母`小写的`不管加不加tag`都不能`转为`json`里的内容，而`大写的`加了`tag`可以`取别名`，不加`tag`则`json`内的字段跟结构体字段`原名一致`。

6、go语言t c p udp具体实现原理？



7、go语言协程调度原理，协程为什么快？



8、你在开发过程中遇到了什么困难以及怎么解决的？

1)内存溢出，pprof

**分析：**

> 从大的范围着手，找到对应的服务异常，从TKE集群的监控发现，x x x服务的**内存**随着时间呈线性增长，然后服务挂掉，初步判断就是服务OOM了。

**问题定位：**

> 用pprof定位，在服务中添加6060监听端点，在nginx中添加路由转发到代码中配置的端口，部署到测试环境复现问题，访问：domain/debug/pprof，发现系统中有大量的goroutine阻塞着，达到了8000多个，而且还在快速增长，平时只有30～300个。
>
> 点击进入goroutine显示详情，可以看到，大部分goroutine都是handleStreams()产生的。找到原因了：goroutine泄漏导致内存泄漏。
>
> 从调用链路图，可以看到grpc.serverStreams占用较大。



 **猜想：**

> 考虑到x x x服务刚好在上一版本优化代码时，使用了stream流技术，怀疑是这块代码导致的。

**验证问题及解决：**

> 解决方式及验证：回退相关代码，再次使用100并发压测发现goroutine稳定在250左右。
>
> 原因分析：goroutine泄漏大概有两个场景：
>
> 1. channel操作阻塞导致runtime期间goroutine一直在阻塞等待；
> 2. goroutine有死循环；
>
> 在grpc-go官网看到有相同的issue, https://github.com/grpc/grpc-go/issues/3728
>
> 因为在堆栈信息表中没有找到本地代码报错的代码行数，大概率怀疑是stream流使用方式不正确导致。
>
> 更新服务到问题发生环境，观察一段时间，内存平稳，稳定在一定范围内，实锤stream的锅。



2)在for循环中执行了defer语句

> defer 在函数退出时才能执行，在 for 执行 defer 会导致资源延迟释放。

9、go语言常见算法，如：查找



10、slice扩容机制？

> Go 中切片扩容的策略是这样的：
>
> 首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容量。否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍。
>
> 否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环增加原来的 1/4 , 直到最终容量大于等于新申请的容量。如果最终容量计算值溢出，则最终容量就是新申请容量。
>
> 情况一：原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址的Slice。
>
> 情况二：原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。
>
> 要复制一个Slice，最好使用Copy函数。



11、读写一个已关闭的chan会发生什么？

- 读**已经关闭**的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。

- - 如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
  - 如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。

- 写**已经关闭**的 `chan` 会 `panic`
