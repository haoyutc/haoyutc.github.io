#### 1、go语言slice和map底层实现原理？

go中数组是固定大小的，而切片是动态的数组，长度并不固定，随着数据的追加而扩容。

#### 2、map底层实现原理？

> Golang 中 map 的底层实现是一个散列表，因此实现 map 的过程实际上就是实现散表的过程。
> 在这个散列表中，主要出现的结构体有两个，一个叫hmap(a header for a go map)，一个叫bmap(a bucket for a Go map，通常叫其bucket)。
>
> hmap如下所示：
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bb1faac1ea3.png)



> 图中有很多字段，但是便于理解 map 的架构，你只需要关心的只有一个，就是标红的字段：buckets 数组。Golang 的 map 中用于存储的结构是 bucket数组。而 bucket(即bmap)的结构是怎样的呢？
> bucket：
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bb53eb6d643.png)

> 相比于 hmap，bucket 的结构显得简单一些，标橙的字段依然是“核心”，我们使用的 map 中的 key 和 value 就存储在这里。
>
> “高位哈希值”数组记录的是当前 bucket 中 key 相关的”索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的 bucket 的指针，使得 bucket 会形成一个链表结构。
> 整体的结构应该是这样的：
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bbcf3d8904e.png)
>
> Golang 把求得的哈希值按照用途一分为二：高位和低位。低位用于寻找当前 key属于 hmap 中的哪个 bucket，而高位用于寻找 bucket 中的哪个 key。
> 需要特别指出的一点是：map中的key/value值都是存到同一个数组中的。这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。
>
> ![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778bc2077dd9d7.png)
>
> Map 的扩容：当 Go 的 map 长度增长到大于加载因子所需的 map 长度时，Go 语言就会将产生一个新的 bucket 数组，然后把旧的 bucket 数组移到一个属性字段 oldbucket中。
>
> 注意：并不是立刻把旧的数组中的元素转移到新的 bucket 当中，而是，只有当访问到具体的某个 bucket 的时候，会把 bucket 中的数据转移到新的 bucket 中。

#### 3、slice底层实现原理？

> 切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化。
> 切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。
> 切片对象非常小，是因为它是只有3个字段的数据结构：

- Data 指向底层数组的指针
- Len 当前切片的长度
- Cap 当前切片的容量，即数组的大小

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

`Data` 是一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度与容量的标识。

这3个字段，就是Go语言操作底层数组的元数据。

![img](http://www.topgoer.cn/uploads/blog/202104/attach_16778ba69a10ebd8.png)

#### 4、map进行有序的排序？

```text
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。
```

#### 5、结构体不加tag可以转json字符串吗？

> - 如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。
> - 如果变量`首字母大写`，则为`public`。
>   - `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
>   - `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用。
>
> ```go
> type Person struct {
> 	id    int    // 小写不加Tag
> 	Name  string `json:"Space"` // 大写加Tag
> 	age   int    `json:"Age"`   // 小写加Tag
> 	Email string // 不加Tag
> }
> 
> func TestJsonConv(t *testing.T) {
> 	p := Person{
> 		id:    111,
> 		Name:  "zhans",
> 		age:   23,
> 		Email: "123@qq.com",
> 	}
> 	fmt.Printf("转换json前结构体内容：%+v\n", p)
> 
> 	pJson, _ := json.MarshalIndent(p, "", "")
> 	//pJson, _ := json.Marshal(p)
> 	fmt.Printf("转换json后结构体内容：%+v\n", string(pJson))
> }
> ```
>
> 结果：
>
> ```go
> 转换json前结构体内容：{id:111 Name:zhans age:23 Email:123@qq.com}
> 转换json后结构体内容：{
> "Space": "zhans",
> "Email": "123@qq.com"
> }
> ```
>
> ## 解释
>
> - 结构体里定义了四个字段，分别对应 `小写无tag`，`小写+tag`，`大写无tag`，`大写+tag`。
> - 转为`json`后首字母`小写的`不管加不加tag`都不能`转为`json`里的内容，而`大写的`加了`tag`可以`取别名`，不加`tag`则`json`内的字段跟结构体字段`原名一致`。

#### 6、go语言t c p udp具体实现原理？



#### 7、go语言协程调度原理，协程为什么快？



#### 8、你在开发过程中遇到了什么困难以及怎么解决的？

1)内存溢出，pprof

**分析：**

> 从大的范围着手，找到对应的服务异常，从TKE集群的监控发现，x x x服务的**内存**随着时间呈线性增长，然后服务挂掉，初步判断就是服务OOM了。

**问题定位：**

> 用pprof定位，在服务中添加6060监听端点，在nginx中添加路由转发到代码中配置的端口，部署到测试环境复现问题，访问：domain/debug/pprof，发现系统中有大量的goroutine阻塞着，达到了8000多个，而且还在快速增长，平时只有30～300个。
>
> 点击进入goroutine显示详情，可以看到，大部分goroutine都是handleStreams()产生的。找到原因了：goroutine泄漏导致内存泄漏。
>
> 从调用链路图，可以看到grpc.serverStreams占用较大。



 **猜想：**

> 考虑到x x x服务刚好在上一版本优化代码时，使用了stream流技术，怀疑是这块代码导致的。

**验证问题及解决：**

> 解决方式及验证：回退相关代码，再次使用100并发压测发现goroutine稳定在250左右。
>
> 原因分析：goroutine泄漏大概有两个场景：
>
> 1. channel操作阻塞导致runtime期间goroutine一直在阻塞等待；
> 2. goroutine有死循环；
>
> 在grpc-go官网看到有相同的issue, https://github.com/grpc/grpc-go/issues/3728
>
> 因为在堆栈信息表中没有找到本地代码报错的代码行数，大概率怀疑是stream流使用方式不正确导致。
>
> 更新服务到问题发生环境，观察一段时间，内存平稳，稳定在一定范围内，实锤stream的锅。



2)在for循环中执行了defer语句

> defer 在函数退出时才能执行，在 for 执行 defer 会导致资源延迟释放。

#### 9、go语言常见算法，如：查找



#### 10、slice扩容机制？

> Go 中切片扩容的策略是这样的：
>
> 首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容量。否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍。
>
> 否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环增加原来的 1/4 , 直到最终容量大于等于新申请的容量。如果最终容量计算值溢出，则最终容量就是新申请容量。
>
> 情况一：原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址的Slice。
>
> 情况二：原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。
>
> 要复制一个Slice，最好使用Copy函数。



#### 11、读写一个已关闭的chan会发生什么？

- 读**已经关闭**的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。

- - 如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
  - 如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。

- 写**已经关闭**的 `chan` 会 `panic`

#### 12、指针占用多大内存？

参考：https://segmentfault.com/a/1190000017473672

- Go 不能进行指针运算。
- 指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。
- 指针也是一种类型，不同于一般类型，指针的值是地址，这个地址指向其他的内存，通过指针可以读取其所指向的地址所存储的值。
- 函数方法的接受者，也可以是指针变量。简单类型和复杂类型在传递的时候不同，复杂类型传值或传指针都是指针拷贝。
- 只声明未赋值的变量，golang都会自动为其初始化为零值，基础数据类型的零值比较简单，引用类型和指针的零值都为nil，nil类型不能直接赋值，因此需要通过new开辟一个内存，或指向一个变量。

#### 13、给出数据表T，用s q l语句或者GORM写出查询语句，name字段重复的结果？

解题思路：

> 1.看到“找重复”的关键字眼，首先要用分组函数（group by），再用聚合函数中的计数函数count()给姓名列计数。
>
> 2. 分组汇总后，生成了一个如下的表。从这个表里选出计数大于1的姓名，就是重复的姓名。

+----------+-----+
| name     | num |
+----------+-----+
| lisi     		|   4 |
| zhangsa   |   2 |
| zhangsan |   4 |
+----------+-----+

解法一：子查询

1、创建一个临时表，将name列进行分组汇总

```sql
select name,count(name) num from T group by name;
```

2、选出临时表中num>1的name

```sql
select name from tmp where num>1;
```

3、结合1与2步骤，将临时表的结果加入到子查询中

```sql
select name name from 
    (select name ,count(name) num from T group by name) tmp
     where num >1;
```

+----------+
| name     |
+----------+
| lisi     |
| zhangsa  |
| zhangsan |
+----------+

解法二：使用having子句

```sql
select name from T group by name having count(name)>1;
```

+----------+
| name     |
+----------+
| lisi     |
| zhangsa  |
| zhangsan |
+----------+

总结：

> 1）考察思路，有两种解题方法，但是使用having语句的方法更高效。
>
> 2）考察对having语句的掌握，很多人会把聚合函数写到where子句中。
>
> 3）熟记SQL子句的书写顺序和运行顺序。
>
> 加强s q l语句高级用法



#### 14、defer关键字使用

>  在Golang中，提供了defer机制来处理成对的操作,如打开、关闭、连接、断开连接、加锁、释放锁、打印日志、异常捕获、资源释放。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。

```go

import (
	"fmt"
	"time"
)

func main() {
	doBusiness()
}
func trace(msg string) func() {
	start := time.Now()
	fmt.Printf("enter %s\n", msg)	// #1
	return func() {
		fmt.Printf("exit %s (%s)\n", msg, time.Since(start))	// #3
	}
}
func doBusiness() {
	defer trace("do business")()
	fmt.Println("doing business...")	// #2
	time.Sleep(3 * time.Second)
}
```

output:

```go
enter do business
doing business...
exit do business (3.000769066s)
```

从输出结果看出，执行顺序是#1、#2、#3，在运行到defer时，先执行了defer函数内的代码，在遇到返回时，跳出，继续执行原来的代码， 待原来的函数执行完毕后，才执行defer函数的返回。

没有返回值的情况执行书序如何？

```go
import (
	"fmt"
	"time"
)

func main() {
	doBusiness()
}
func trace(msg string)  {
  // 只做打印
	fmt.Printf("enter %s\n", msg)		// #2
}
func doBusiness() {
  // 对于没有返回值的函数，defer调用其时，后面不能加()调用符号
	defer trace("do business")
	fmt.Println("doing business...")	// #1
	time.Sleep(3 * time.Second)
}
```

Output:

```go
doing business...
enter do business
```

从输出结果中看出，defer在原函数执行完成后执行

多个defer的执行顺序类似于栈，先进后出

```go
func main() {
    defer fmt.Println(1)
    defer fmt.Println(2)
    defer fmt.Println(3)
    defer fmt.Println(4)
}
```

Output:

```go
4
3
2
1
```



结论：

> defer机制在其调用的函数没有返回值时，在原函数执行完毕后，才执行defer函数。 若调用的函数有返回，则会在执行原函数过程中遇到defer时，先执行defer返回值之前的代码，再执行原函数，原函数执行完毕后， 才返回defer函数的返回值，如果这个返回值是一个函数，即执行这个函数。



#### 15、make与new的区别？

在go中make和new是两个内置函数，主要用来创建并分配类型的内存空间。

new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化

**New** 

```go
// The new built-in function allocates memory. The first argument is a type,
// not a value, and the value returned is a pointer to a newly
// allocated zero value of that type.
func new(Type) *Type
```

从上面的代码可以看出，new 函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。同时 new 函数会把分配的内存置为零，也就是类型的零值。

【示例】使用 new 函数为变量分配内存空间。

```go
var sum *int
sum = new(int) //分配空间
*sum = 98
fmt.Println(*sum)
```

当然，new 函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用 new 函数来分配空间，如下所示：

```go
type Student struct {
   name string
   age int
}

var s *Student
s = new(Student) //分配空间
s.name ="dequan"

fmt.Println(s)
```

这里如果我们不使用 new 函数为自定义类型分配空间（将第 7 行注释），就会报错：

panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x80bd277]
goroutine 1 [running]:

new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。

**make**

make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。

```go
// The make built-in function allocates and initializes an object of type
// slice, map, or chan (only). Like new, the first argument is a type, not a
// value. Unlike new, make's return type is the same as the type of its
// argument, not a pointer to it. The specification of the result depends on
// the type:
// Slice: The size specifies the length. The capacity of the slice is
// equal to its length. A second integer argument may be provided to
// specify a different capacity; it must be no smaller than the
// length, so make([]int, 0, 10) allocates a slice of length 0 and
// capacity 10.
// Map: An empty map is allocated with enough space to hold the
// specified number of elements. The size may be omitted, in which case
// a small starting size is allocated.
// Channel: The channel's buffer is initialized with the specified
// buffer capacity. If zero, or the size is omitted, the channel is
// unbuffered.
func make(t Type, size ...IntegerType) Type
```

通过上面的代码可以看出 make 函数的 t 参数必须是 chan（通道）、map（字典）、slice（切片）中的一个，并且返回值也是类型本身。

注意：make 函数只用于 map，slice 和 channel，并且不返回指针。如果想要获得一个显式的指针，可以使用 new 函数进行分配，或者显式地使用一个变量的地址。

Go语言中的 new 和 make 主要区别如下：

- make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；
- new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；
- new 分配的空间被清零。make 分配空间后，会进行初始化；

#### 16、main函数之前做了哪些事情？init函数执行的一个过程？

`init`函数
go语言中`init`函数用于包`(package)`的初始化，该函数是go语言的一个重要特性。

有下面的特征：

```
1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等

2 每个包可以拥有多个init函数

3 包的每个源文件也可以拥有多个init函数

4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)

5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序

6 init函数不能被其他函数调用，而是在main函数执行之前，自动被调用
```

`init`函数和`main`函数的异同:

```
相同点：
	两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。
不同点：
    init可以应用于任意包中，且可以重复定义多个。
    main函数只能用于main包中，且只能定义一个。
```

> 两个函数的执行顺序：
> 对同一个go文件的`init()`调用顺序是从上到下的。
> 对同一个`package`中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的`init()`函数。
> 对于不同的`package`，如果不相互依赖的话，按照main包中"先import的后调用"的顺序调用其包中的`init()`，如果`package`存在依赖，则先调用最早被依赖的`package`中的`init()`，最后调用main函数。
>
> 如果init函数中使用了`println()`或者`print()`你会发现在执行过程中这两个不会按照你想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。

#### 17、golang的CSP模型？



Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。

Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供 “先进先出” 的特性；它还能影响 goroutine 的阻塞和唤醒。

相信大家一定见过一句话：

> **Do not communicate by sharing memory; instead, share memory by communicating.**

**不要通过共享内存来通信，而要通过通信来实现内存共享。**

#### 18、Java和golang的垃圾回收算法有什么区别？为什么这么选择？
